# 三国杀专业分析面板 (SGSFish)

本项目是一个基于 Python 实现的三国杀专业分析面板，旨在模拟玩家决策过程，通过量化评估动作实体（卡牌/技能）的价值、考虑它们之间的相互影响（包括基于作用域的条件影响）、根据战局动态调整策略权重，并结合概率模型估计对手手牌，以提供当前回合最佳行动序列（包含具体作用域选择）及其预期得分。

## 核心概念

本项目基于以下核心逻辑构建：

1.  **属性系统:**
    *   **动作实体 (ActionEntity):** 定义了基础的攻击、防御、辅助属性值。
    *   **武将:** 每个武将拥有基础血量上限。

2.  **动作实体 (ActionEntity):**
    *   合并了原有的卡牌和技能概念，代表一个可执行的动作。
    *   包含基础属性 (攻击、防御、辅助)。
    *   **状态属性:**
        *   `timing`: 发动时机 (如 0=出牌阶段, 2=判定阶段)。
        *   `response_suit`, `response_rank_range`: 响应特定花色/数字的要求 (如【闪电】响应黑桃2-9)。
        *   `scope`: 可选的作用域列表 (如【过河拆桥】可选 `[1, 2, 3]` 代表手牌区、装备区、判定区)。

3.  **影响系统:**
    *   某些动作实体在使用后，可能会对其后使用的特定动作实体产生临时的属性修正。
    *   例如，“过河拆桥”作用于**手牌区**(scope=1)时，可能会提升后续“杀”的攻击评估价值。
    *   影响现在可以指定 `required_scope`，即该影响只有在源动作选择了特定作用域时才生效。
    *   这些影响关系、修正值和作用域要求存储在数据库中。

4.  **动态权重:**
    *   AI 的决策倾向会根据战场局势动态调整：
        *   **敌方血量越低，攻击属性的权重越高**，鼓励进攻。
        *   **己方血量越低，防御属性的权重越高**，鼓励保守或自保。
    *   辅助属性的权重当前版本是固定的。

5.  **概率模型:**
    *   通过记录牌堆的初始构成、己方手牌以及（理论上）场上已出现的牌，结合对手当前的手牌数量，来估算对手手牌中持有各种动作实体的可能性（概率）。
    *   *当前实现为简化模型，基于剩余牌堆比例估算。*

6.  **最佳序列查找:**
    *   核心决策逻辑。
    *   **评估不同作用域:** 对于具有可选作用域的动作（如【过河拆桥】），算法现在会评估选择不同作用域的情况。
    *   **实现方式:** 将每个 (动作实体, 选定作用域) 的组合视为一个独立的“动作选择”。算法会遍历这些“动作选择”的所有可能排列组合（包括不同长度的子序列）。
    *   对每个序列，结合**动态权重**和**影响系统**（现在考虑了影响的 `required_scope` 和动作选择的 `chosen_scope`）计算其综合得分。
    *   找出总得分最高的序列作为推荐的最佳行动顺序（包含每个动作选择的作用域）。
    *   *注意：评估不同作用域会显著增加计算复杂度，特别是当手牌中有多张具有可选作用域的牌时。未来可能需要优化搜索算法。*
    *   *理想的排序方式仍然是：优先最大化己方收益，其次考虑最小化敌方潜在威胁。当前实现主要侧重于最大化己方得分。*
6.  **最佳序列查找:**
    *   核心决策逻辑。
    *   **评估不同作用域:** 对于具有可选作用域的动作（如【过河拆桥】），算法现在会评估选择不同作用域的情况。
    *   **实现方式:** 将每个 (动作实体, 选定作用域) 的组合视为一个独立的“动作选择”。算法会遍历这些“动作选择”的所有可能排列组合（包括不同长度的子序列）。
    *   对每个序列，结合**动态权重**和**影响系统**（现在考虑了影响的 `required_scope` 和动作选择的 `chosen_scope`）计算其综合得分。
    *   找出总得分最高的序列作为推荐的最佳行动顺序（包含每个动作选择的作用域）。
    *   *注意：评估不同作用域会显著增加计算复杂度，特别是当手牌中有多张具有可选作用域的牌时。未来可能需要优化搜索算法。*
    *   *理想的排序方式仍然是：优先最大化己方收益，其次考虑最小化敌方潜在威胁。当前实现主要侧重于最大化己方得分。*

7.  **数据存储:**
    *   使用 SQLite 数据库 (`sgs_data.db`) 存储所有基础数据，包括：
        *   动作实体的名称、基础属性、状态属性（包括 `scope`）。
        *   实体之间的影响关系、修正值及作用域要求 (`required_scope`)。
        *   动作实体的名称、基础属性、状态属性（包括 `scope`）。
        *   实体之间的影响关系、修正值及作用域要求 (`required_scope`)。
        *   英雄的名称、血量上限。
        *   (*未来*) 技能的详细数据。
        *   (*未来*) 技能的详细数据。
    *   这使得数据与逻辑分离，方便维护和扩展。

## 项目结构

*   [`database.py`](/workspaces/sgsfish/database.py): 负责数据库的初始化、连接、数据填充（初始实体、英雄、影响）以及从数据库加载数据。
*   [`game_elements.py`](/workspaces/sgsfish/game_elements.py): 定义核心游戏元素的数据类，如 `ActionEntity`, `Hero`, `Player`, `AttributeSet`。还包括从数据库加载数据后创建实体原型的逻辑。
*   [`game_logic.py`](/workspaces/sgsfish/game_logic.py): 包含主要的决策逻辑，如权重计算 (`calculate_weights`)、单步行动评估 (`evaluate_action`)、概率模型 (`estimate_opponent_hand_probabilities`) 和核心的最佳序列查找 (`find_best_sequence`)。
*   [`main.py`](/workspaces/sgsfish/main.py): 项目的入口点，设置并运行一个简单的 1v1 测试场景，调用 `game_logic` 中的函数并打印结果。包含数据库自动初始化的检查逻辑。
*   [`database.py`](/workspaces/sgsfish/database.py): 负责数据库的初始化、连接、数据填充（初始实体、英雄、影响）以及从数据库加载数据。
*   [`game_elements.py`](/workspaces/sgsfish/game_elements.py): 定义核心游戏元素的数据类，如 `ActionEntity`, `Hero`, `Player`, `AttributeSet`。还包括从数据库加载数据后创建实体原型的逻辑。
*   [`game_logic.py`](/workspaces/sgsfish/game_logic.py): 包含主要的决策逻辑，如权重计算 (`calculate_weights`)、单步行动评估 (`evaluate_action`)、概率模型 (`estimate_opponent_hand_probabilities`) 和核心的最佳序列查找 (`find_best_sequence`)。
*   [`main.py`](/workspaces/sgsfish/main.py): 项目的入口点，设置并运行一个简单的 1v1 测试场景，调用 `game_logic` 中的函数并打印结果。包含数据库自动初始化的检查逻辑。

## 如何运行

1.  确保你的环境中安装了 Python (3.x)。
2.  打开终端或命令提示符，导航到项目目录。
3.  运行主程序：
    ```bash
    python main.py
    ```
4.  程序将首先尝试加载数据。如果数据库文件 (`sgs_data.db`) 不存在或数据不完整，它会自动尝试调用 `database.py` 中的函数来初始化数据库并填充初始数据。
5.  之后，程序将执行预设的 1v1 测试场景，并输出推荐的行动顺序（包含作用域选择）和对敌方手牌的概率估计。

*   **注意:** 如果 `main.py` 中的自动初始化逻辑失败，或者你想强制重新创建数据库，可以手动运行：
    ```bash
    python database.py
    ```
    (请注意，这将删除现有的 `sgs_data.db` 文件并重新创建)

## 待办事项 / 未来计划

*   [ ] **完整实现技能系统:** 将技能作为 `ActionEntity` 添加到数据库，并完善相关逻辑。
*   [ ] **完善概率模型:** 考虑弃牌堆、装备区、判定区的牌，使用更精确的概率计算方法。
*   [ ] **优化序列查找:** 当前使用 `itertools.permutations` 遍历所有“动作选择”的组合，复杂度较高。探索更优化的搜索算法（如A*搜索、蒙特卡洛树搜索、加入启发式剪枝等）。
*   [ ] **实现完整排序逻辑:** 在 `find_best_sequence` 中加入对敌方潜在威胁的评估。
*   [ ] **扩展数据:** 添加更多的三国杀实体、英雄数据。
*   [ ] **实现游戏状态机:** 更精细地模拟游戏阶段和动作合法性检查。
*   [ ] **构建交互界面或模拟器:** 创建用户界面或集成到模拟器。
*   [ ] **完整实现技能系统:** 将技能作为 `ActionEntity` 添加到数据库，并完善相关逻辑。
*   [ ] **完善概率模型:** 考虑弃牌堆、装备区、判定区的牌，使用更精确的概率计算方法。
*   [ ] **优化序列查找:** 当前使用 `itertools.permutations` 遍历所有“动作选择”的组合，复杂度较高。探索更优化的搜索算法（如A*搜索、蒙特卡洛树搜索、加入启发式剪枝等）。
*   [ ] **实现完整排序逻辑:** 在 `find_best_sequence` 中加入对敌方潜在威胁的评估。
*   [ ] **扩展数据:** 添加更多的三国杀实体、英雄数据。
*   [ ] **实现游戏状态机:** 更精细地模拟游戏阶段和动作合法性检查。
*   [ ] **构建交互界面或模拟器:** 创建用户界面或集成到模拟器。

## 贡献

欢迎提出建议、报告 Bug 或贡献代码！请通过 GitHub Issues 或 Pull Requests 进行。
